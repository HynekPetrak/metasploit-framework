# -*- coding: binary -*-

#
# This mixin is a wrapper around Net::LDAP
#

require 'net-ldap'

module Msf
  module Exploit::Remote::LDAP
    def initialize(info = {})
      super

      register_options([
        Opt::RHOST,
        Opt::RPORT(389),
        OptBool.new('SSL', [false, 'Enable SSL on the LDAP connection', false]),
        OptString.new('BIND_DN', [false, 'The username to authenticate to LDAP server']),
        OptString.new('BIND_PW', [false, 'Password for the BIND_DN'])
      ])

      register_advanced_options([
        OptFloat.new('ConnectTimeout', [true, 'Timeout for LDAP connect', 10.0])
      ])
    end

    def rhost
      datastore['RHOST']
    end

    def rport
      datastore['RPORT']
    end

    def peer
      "#{rhost}:#{rport}"
    end

    def ldap_connect(opts = {}, &block)
      connect_opts = {
        host: rhost,
        port: rport,
        connect_timeout: datastore['ConnectTimeout']
      }

      if datastore['SSL']
        connect_opts[:encryption] = {
          method: :simple_tls,
          tls_options: {
            verify_mode: OpenSSL::SSL::VERIFY_NONE
          }
        }
      end

      if datastore['BIND_DN']
        connect_opts[:auth] = {
          method: :simple,
          username: datastore['BIND_DN']
        }
        if datastore['BIND_PW']
          connect_opts[:auth][:password] = datastore['BIND_PW']
        end
      end

      Net::LDAP.open(connect_opts.merge(opts), &block)
    end

    def get_naming_contexts(ldap)
      vprint_status("#{peer} Getting root DSE")

      unless (root_dse = ldap.search_root_dse)
        print_error("#{peer} Could not retrieve root DSE")
        return
      end

      vprint_line(root_dse.to_ldif)

      naming_contexts = root_dse[:namingcontexts]

      # NOTE: Net::LDAP converts attribute names to lowercase
      if naming_contexts.empty?
        print_error("#{peer} Empty namingContexts attribute")
        return
      end

      naming_contexts
    rescue Net::LDAP::Error => e
      print_error("#{peer} #{e.class}: #{e.message}")
      nil
    end

    def discover_base_dn(ldap)
      naming_contexts = get_naming_contexts(ldap)

      unless naming_contexts
        print_error("#{peer} Base DN cannot be determined")
        return
      end

      # NOTE: We assume the first namingContexts value is the base DN
      base_dn = naming_contexts.first

      print_good("#{peer} Discovered base DN: #{base_dn}")
      base_dn
    rescue Net::LDAP::Error => e
      print_error("#{peer} #{e.class}: #{e.message}")
      nil
    end
  end
end
